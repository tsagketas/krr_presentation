\documentclass[11pt,aspectratio=169]{beamer}

% --- Theme & look ---
\usetheme{Madrid}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{blocks}[rounded][shadow=false]
\useinnertheme{rounded}
\usefonttheme{professionalfonts}

% Slightly larger, more readable beamer typography
\setbeamerfont{frametitle}{size=\Large}
\setbeamerfont{block title}{size=\large}
\setbeamerfont{block title alerted}{size=\large}

% --- Language & fonts (XeLaTeX + Babel) ---
\usepackage{fontspec}
\usepackage[main=greek,english]{babel}

% Fonts with Greek support (shipped with TeX distributions)
\defaultfontfeatures{Ligatures=TeX}
% Use common Windows fonts to avoid font lookup issues
\setsansfont{Calibri}
\setmainfont{Cambria}
\setmonofont{Consolas}

\usepackage{microtype}

% --- Utilities ---
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{ragged2e}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,calc,fit,shapes.geometric}

% --- Custom commands (Greek text + English terms) ---
\newcommand{\latin}[1]{\foreignlanguage{english}{#1}}
\newcommand{\eng}[1]{\foreignlanguage{english}{#1}}
\newcommand{\term}[2]{#1 (\eng{#2})}
\newcommand{\code}[1]{\texttt{\foreignlanguage{english}{#1}}}
\newcommand{\smallcode}[1]{{\footnotesize\texttt{\foreignlanguage{english}{#1}}}}
\newcommand{\sigil}[1]{\foreignlanguage{english}{\texttt{#1}}}
\newcommand{\krrsep}{\hspace{0.8em}\textcolor{black!40}{\(\cdot\)}\hspace{0.8em}}
\newcommand{\aspcode}[1]{\foreignlanguage{english}{{\footnotesize\nolinkurl{#1}}}}

% --- Colors (single blue system) ---
\definecolor{KRRBlue}{RGB}{13,71,161}
\definecolor{KRRGray}{RGB}{38,50,56}
\setbeamercolor{title}{fg=white,bg=KRRBlue}
\setbeamercolor{frametitle}{fg=white,bg=KRRBlue}
\setbeamercolor{structure}{fg=KRRBlue}
\setbeamercolor{block title}{fg=white,bg=KRRBlue}
\setbeamercolor{block body}{bg=black!2}
\setbeamercolor{block title alerted}{fg=white,bg=KRRBlue}
\setbeamercolor{block body alerted}{bg=black!2}
\setbeamercolor{block title example}{fg=white,bg=KRRBlue}
\setbeamercolor{block body example}{bg=black!2}
\setbeamercolor{alerted text}{fg=KRRBlue}

% --- Footline (clean + slide numbers) ---
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.85\paperwidth,ht=2.6ex,dp=1.2ex,leftskip=0.8em]{author in head/foot}%
      \usebeamerfont{author in head/foot}\insertshorttitle\krrsep\insertshortinstitute
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.15\paperwidth,ht=2.6ex,dp=1.2ex,center]{date in head/foot}%
      \usebeamerfont{date in head/foot}\insertframenumber/\inserttotalframenumber
    \end{beamercolorbox}%
  }%
}

% (No section-only title frames.)

% --- Title info ---
\title[\eng{ASP} \& \eng{Spack}]{\eng{Answer Set Programming for HPC Dependency Solving}}
\author[\eng{KRR}]{Κωνσταντίνος Καϊμάκης (mtn2508)\\Γιώργος Νάζος (mtn2519) \quad Γιώργος Πλέσσιας (mtn2524) \quad Ορέστης Τσαγκέτας (mtn2527)}
\date{12 Φεβρουαρίου 2026}

\begin{document}

% --- Title ---
\begin{frame}[plain]
  \vspace*{0.2cm}
  \begin{center}
    {\color{KRRBlue}\LARGE \inserttitle \par}
    \vspace{0.30cm}
    \begin{tikzpicture}
      \draw[KRRBlue, line width=1.6pt] (0,0) -- (11.0,0);
    \end{tikzpicture}
  \end{center}

  \vfill
  \begin{center}
    {\footnotesize \insertauthor \par}
    \vspace{0.1cm}
    {\footnotesize \insertinstitute \par}
  \end{center}
  \vfill
  \begin{center}
    {\footnotesize \insertdate \par}
  \end{center}
\end{frame}

% --- Agenda ---
\begin{frame}{Δομή}
  \begin{itemize}
    \item Γιατί το \eng{HPC} κάνει το πρόβλημα δύσκολο
    \item \eng{Spack specs} και \eng{concretization}
    \item Μοντελοποίηση σε \eng{ASP}: facts / rules / constraints
    \item \eng{Virtual dependencies}, \eng{conditional dependencies}, \eng{variants}
    \item Βελτιστοποίηση + \eng{reuse}
    \item Αποτελέσματα / περιορισμοί
  \end{itemize}
\end{frame}

\section{Το πρόβλημα στο \eng{HPC}}

\begin{frame}{ \eng{HPC dependency resolution}}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.56\textwidth}
      \begin{block}{\eng{HPC Stack}}
        \begin{itemize}
          \item Εκδόσεις: πολλαπλές εκδόσεις συνυπάρχουν
          \item Compilers: \eng{GCC} \(\Rightarrow\) \eng{ABI} ασυμβατότητες
          \item Variants: \code{+mpi}, \code{+cuda}, \code{\textasciitilde{}debug}, \dots
          \item Targets: \eng{Skylake}/\eng{Power9}/\eng{GPU}, \dots
        \end{itemize}
      \end{block}
      \vspace{0.2cm}
      \begin{alertblock}{Το πρόβλημα}
        \justifying
        Ο γράφος είναι \eng{DAG}, αλλά κάθε κόμβος είναι package και τα edges είναι dependencies.
        Το γενικό πρόβλημα είναι \eng{NP-complete}.
      \end{alertblock}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{block}{Διαισθητικό διάγραμμα}
        \centering
        \begin{tikzpicture}[node distance=7mm, font=\small, scale=0.95, transform shape]
          \tikzset{
            pkg/.style={rounded corners, draw=KRRBlue, fill=black!2, inner sep=4pt, align=center},
            dep/.style={-Latex, thick, draw=black!70}
          }
          \node[pkg] (A) {App\\\eng{(root)}};
          \node[pkg, below left=of A] (B) {Lib B\\\code{@1.x}};
          \node[pkg, below right=of A] (C) {Lib C\\\code{+cuda?}};
          \node[pkg, below=of B] (D) {MPI\\\eng{virtual}};
          \node[pkg, below=of C] (E) {Compiler\\\code{\%gcc}};
          \draw[dep] (A) -- (B);
          \draw[dep] (A) -- (C);
          \draw[dep] (B) -- (D);
          \draw[dep] (C) -- (D);
          \draw[dep] (C) -- (E);
          \node[align=left, text width=0.90\linewidth, below=9mm of E] {\footnotesize
            Κάθε βέλος = περιορισμοί.\\
            Κάθε κόμβος = επιλογές/παραλλαγές.
          };
        \end{tikzpicture}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{ Υπάρχοντες \eng{HPC package managers}}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.48\textwidth}
      \begin{block}{\eng{Single prefix package managers}}
        \begin{itemize}
          \item κοινό \eng{prefix} \(\Rightarrow\) 1 έκδοση/πακέτο
          \item πιο «στενός» χώρος αναζήτησης από \eng{HPC}
        \end{itemize}
      \end{block}
      \begin{block}{\eng{Language managers}}
        \begin{itemize}
          \item συχνά αγνοούν system deps
          \item \eng{ad-hoc} επίλυση
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{alertblock}{Το παλιό \eng{Spack}}
        \begin{itemize}
          \item αποφάσεις «χωρίς επιστροφή»
          \item false negatives: αποτυγχάνει ενώ υπάρχει λύση
        \end{itemize}
      \end{alertblock}
      \vspace{0.2cm}
      \begin{block}{Τι θέλουμε}
        \begin{itemize}
          \item Πληρότητα: αν υπάρχει λύση, να βρεθεί
          \item Βελτιστότητα: εύρεση βέλτιστης λύσης
          \item Συντηρησιμότητα: κανόνες, όχι \eng{complex} \eng{heuristics}
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\section{Από \eng{Spec} σε \eng{DAG}: ο \eng{concretizer}}

\begin{frame}{\eng{Spack spec syntax}}
  \begin{block}{Περιορισμοί}
    \begin{itemize}
      \item \sigil{@} έκδοση: \code{hdf5@1.10.2}
      \item \sigil{\%} μεταγλωττιστής: \code{\%gcc@9.3.0}
      \item \sigil{+}/\sigil{\textasciitilde{}} variants: \code{+mpi}, \code{\textasciitilde{}shared}
      \item \sigil{\string^} εξάρτηση: \code{\string^mpich@3.3}
    \end{itemize}
  \end{block}

  \begin{alertblock}{Παράδειγμα}
    \smallcode{spack install hdf5@1.10.2+mpi \%gcc@9.3.0 \string^mpich@3.3}
  \end{alertblock}

  \begin{block}{\eng{Concretization}}
    \justifying
    Η διαδικασία μετατροπής ενός Abstract Spec σε Concrete Spec έτσι ώστε: (i) να ικανοποιούνται οι περιορισμοί και να βελτιστοποιούνται τα κριτήρια, (ii) να επιλύονται όλα τα virtual dependencies, και (iii) να μην υπάρχουν συγκρούσεις.
  \end{block}
\end{frame}

\section{\eng{ASP}: Facts, Rules, Constraints}

\begin{frame}{\eng{ASP Implementation}}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.54\textwidth}
      \begin{block}{\eng{Declarative} μοντέλο}
        \begin{itemize}
          \item Facts: δεδομένα
          \item Rules: παραγωγή γνώσης
          \item Constraints: εγκυρότητα
        \end{itemize}
      \end{block}
      \begin{block}{Ροή}
        \begin{itemize}
          \item Python \(\rightarrow\) παράγει facts μέσω του Package DSL
          \item Grounding \(\rightarrow\) προτασιακό πρόγραμμα
          \item \eng{clingo} \(\rightarrow\) stable models
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}{0.44\textwidth}
      \begin{block}{Παράδειγμα pipeline}
        \centering
        \begin{tikzpicture}[font=\small, node distance=6mm, every node/.style={minimum width=1.4cm, minimum height=0.6cm}]
          \tikzset{
            box/.style={rounded corners, draw=KRRBlue, fill=black!2, inner sep=4pt, align=center},
            arr/.style={-Latex, thick, draw=black!70}
          }
          \node[box] (spec) {\eng{Spec}};
          \node[box, right=of spec] (facts) {\eng{Facts}};
          \node[box, right=of facts] (asp) {\eng{ASP}};
          \node[box, right=of asp] (sol) {\eng{Sol}};
          \draw[arr] (spec) -- (facts);
          \draw[arr] (facts) -- (asp);
          \draw[arr] (asp) -- (sol);
        \end{tikzpicture}
      \end{block}
      \vspace{0.42cm}
      \begin{block}{Γιατί όχι \eng{SAT};}
        \justifying
        Η ASP εγγυάται τερματισμό και επιτρέπει τη μοντελοποίηση multi-objective optimization με φυσικό τρόπο.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Παράδειγμα}
  \begin{block}{Πακέτα, εκδόσεις, deps}
    \justifying
    Η Python μεταφράζει τη γνώση των \code{package.py} σε facts, π.χ.:
    \vspace{0.2mm}

    \begin{center}
      \fbox{\parbox{0.92\linewidth}{
        \small
        \eng{package("zlib").}\\
        \eng{version\_declared("zlib","1.2.11",0).}\\
        \eng{possible\_dependency("hdf5","mpi").}
      }}
    \end{center}
  \end{block}
  
  \begin{block}{Προέλευση των Γεγονότων}
  \begin{itemize}
    \item Metadata
    \item Απαιτήσεις χρήστη
    \item Κατάσταση συστήματος
  \end{itemize}
  \end{block}
  \begin{alertblock}{Σχόλιο}
    \justifying
    Για ένα ρεαλιστικό πρόβλημα δημιουργούνται δεκάδες χιλιάδες facts πριν καν ξεκινήσει το solving.
  \end{alertblock}
\end{frame}

\begin{frame}{Κανόνας επιλογής κόμβων}
  \begin{block}{Choice rule}
    \begin{center}
      \fbox{\parbox{0.92\linewidth}{
        \small
        \aspcode{1 { version(P,V) : possible_version(P,V) } 1 :- node(P).}
      }}
    \end{center}
  \end{block}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.54\textwidth}
      \begin{block}{Τι σημαίνει}
        \begin{itemize}
          \item για κάθε \eng{node(P)} επιλέγουμε ακριβώς 1 \eng{V}
          \item αποκλείει «διπλές» εκδόσεις στον ίδιο κόμβο λύσης
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}{0.44\textwidth}
      \begin{alertblock}{Σύγκριση}
        \justifying
        Αντί για διαδικαστικό backtracking, το backtracking γίνεται εσωτερικά στον solver.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Κατασκευή γράφου}
  \begin{block}{Propagation rule}
    \begin{center}
      \fbox{\parbox{0.92\linewidth}{
        \small
        \aspcode{node(Dep) :- node(Pkg), depends_on(Pkg,Dep).}
      }}
    \end{center}
  \end{block}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.54\textwidth}
      \begin{block}{Κέρδος}
        \justifying
        Ο γράφος «χτίζεται» λογικά και ο solver εξερευνά ταυτόχρονα τις επιλογές σε βάθος, χωρίς να εγκλωβίζεται
        από πρώιμες επιλογές.
      \end{block}
    \end{column}
    \begin{column}{0.44\textwidth}
      \begin{alertblock}{Στην πράξη}
        \justifying
        Αυτό είναι η βάση για την πληρότητα: αν υπάρχει λύση, θα βρεθεί.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\section{\eng{Virtuals}, \eng{Conditionals}, \eng{Variants}}

\begin{frame}{Virtual dependencies}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.56\textwidth}
      \begin{block}{Ιδέα}
        \justifying
        Για δυνατότητες τύπου \eng{MPI}, δεν ζητάμε «πακέτο», ζητάμε λειτουργία. Ο solver επιλέγει provider.
      \end{block}
      \begin{block}{Κανόνας}
        \begin{center}
          \fbox{\parbox{0.92\linewidth}{
            \small
            \aspcode{1 { provider(V, P) : provides(P, V) } 1 :- node(P), depends_on(P, V).}
            % \aspcode{1 \{ provider(Virt,Pkg) : provides(Pkg,Virt) \} 1 :- node(P), depends_on(P,Virt).}
          }}
        \end{center}
      \end{block}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{block}{Παράδειγμα}
        \begin{itemize}
          \item \eng{hdf5} depends on \eng{mpi}
          \item providers: \eng{mpich}, \eng{openmpi}
          \item επιλογή βάσει προτιμήσεων + συγκρούσεων
        \end{itemize}
      \end{block}
      \begin{alertblock}{Σημείο-κλειδί}
        \justifying
        Η επιλογή provider είναι μέρος της ίδιας ενιαίας βελτιστοποίησης.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Εξάρτηση από variant}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.54\textwidth}
      \begin{block}{Πρόβλημα}
        \justifying
        Ο παλιός αλγόριθμος αποφάσιζε τις τιμές των variants πριν εξετάσει τις εξαρτήσεις. Πιθανό να οδηγησεις σε αδιέξοδο.
      \end{block}
      \begin{block}{ASP}
        \justifying
        Ο solver αποφασίζει ταυτόχρονα τις τιμές των \eng{variants} και το αν ενεργοποιείται η αντίστοιχη εξάρτηση.

        \begin{center}
          \fbox{\parbox{0.95\linewidth}{
            \scriptsize
            \raggedright
            \texttt{condition\_holds(ID) :- condition(ID), node(P),}\\
            \texttt{variant\_value(P, bzip2, true),}\\
            \texttt{condition\_requirement(ID, "variant\_value", P, "bzip2", "true").}\\[0.5em]
            \texttt{dependency\_enabled(P, bzip2) :- condition\_holds(ID),}\\
            \texttt{dependency\_condition(ID, P, bzip2).}
          }}
        \end{center}
      \end{block}
    \end{column}
    \begin{column}{0.42\textwidth}
      \begin{alertblock}{Γιατί είναι δυνατό}
        \justifying
        O solver εξετάζει όλο τον χώρο αναζήτησης και κάνει backtracking όπου χρειαστεί.
      \end{alertblock}
      \begin{block}{Αποτέλεσμα}
        \begin{itemize}
          \item λιγότερα αδιέξοδα
          \item πιο «σωστές» λύσεις σε σύνθετα specs
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\section{Βελτιστοποίηση: από έγκυρο σε βέλτιστο}

\begin{frame}{Λεξικογραφική βελτιστοποίηση}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.60\textwidth}
      \begin{block}{Ιδέα}
        \justifying
        Δεν αρκεί «να υπάρχει λύση». Θέλουμε λύση που να ακολουθεί ιεραρχημένες προτιμήσεις.
      \end{block}
      \begin{block}{Ενδεικτικά κριτήρια}
        \begin{itemize}
          \item Deprecated versions: αποφυγή μη ασφαλών/παρωχημένων
          \item Version age (roots): νεότερες εκδόσεις για roots
          \item Variant defaults (roots): τήρηση defaults όπου γίνεται
          \item Preferred providers: π.χ. \eng{MPICH} αντί \eng{OpenMPI}
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}{0.36\textwidth}
      \begin{alertblock}{Συνέπεια}
        \justifying
        Κριτήριο 1 υπερισχύει απόλυτα του 2: κανένα trade-off που «σπάει» την ασφάλεια.
      \end{alertblock}
      \begin{block}{Συνοχή στο \eng{HPC}}
        \begin{itemize}
          \item Compiler mismatch \(\downarrow\) (ABI)
          \item Target mismatch \(\downarrow\)
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}
\begin{frame}{Κριτήρια Βελτιστοποίησης}
\small
\justifying

Ο \eng{solver} ελαχιστοποιεί τα παρακάτω κριτήρια με
λεξικογραφική σειρά:

\vspace{2mm}

\begin{columns}[T,onlytextwidth]

\begin{column}{0.48\textwidth}
\begin{block}{Ασφάλεια (1)}
Χρήση \eng{deprecated} εκδόσεων.
\vspace{2.2em}
\end{block}

\begin{block}{Root Πακέτα (2--5)}
\begin{itemize}
  \item Παλαιότητα εκδόσεων, μη-προτιμώμενοι πάροχοι.
  \item Αποκλίσεις από τις προεπιλεγμένες τιμές \newline των \eng{variants}.
\end{itemize}
\end{block}
\end{column}

\begin{column}{0.52\textwidth}
\begin{block}{Εξαρτήσεις / Non-roots (6--7, 11--12)}
\begin{itemize}
  \item Παλαιότητα εκδόσεων και
  \eng{variant/provider defaults} για τα πακέτα του υπόλοιπου γράφου.
\end{itemize}
\end{block}

\begin{block}{Συνοχή Συστήματος (8--10, 13--15)}
\begin{itemize}
  \item Mismatches: Ασυμφωνίες σε \eng{compiler}, \eng{OS} και
  \eng{target} μεταξύ εξαρτήσεων.
  \item Preferences: Επιλογή μη-προτιμώμενων \eng{compilers},
  \eng{OS} ή \eng{targets}.
\end{itemize}
\end{block}
\end{column}

\end{columns}

\vspace{2mm}

\begin{block}{Σημείωση}
Οι προτιμήσεις των \eng{root} πακέτων υπερισχύουν πάντα των εξαρτήσεων
(«flow downward»).
\end{block}

\end{frame}


\begin{frame}{Resuability \& Buildcache}
\begin{columns}[T,onlytextwidth]
  \begin{column}{0.56\textwidth}
    \begin{block}{Το «κόλπο» με τους κάδους}
      \justifying
      Διπλασιάζουμε κριτήρια: άλλα για νέα builds και άλλα για
      εγκατεστημένα πακέτα, και εισάγουμε ενδιάμεσα στόχο:
      ελαχιστοποίηση builds.
    \end{block}
  \end{column}

  \begin{column}{0.40\textwidth}
    \begin{block}{Γιατί έχει σημασία}
      \small
      \begin{itemize}
        \item builds στο \eng{HPC} είναι ακριβά
        \item reuse = γρηγορότερα installs \(\Rightarrow\) καλύτερο UX
      \end{itemize}
    \end{block}
  \end{column}
\end{columns}



\begin{block}{Λογική πολιτική}
\justifying
Αν ένα ήδη εγκατεστημένο ή προ-μεταγλωττισμένο πακέτο
ικανοποιεί τους περιορισμούς, ο solver το επιλέγει για να εξοικονομήσει
χρόνο και πόρους.

\vspace{3mm}

\centering
\begin{tikzpicture}[font=\scriptsize, node distance=8mm]
  \tikzset{
    b/.style={rounded corners, draw=KRRBlue, fill=black!2, inner sep=5pt, align=center},
    arr/.style={-Latex, thick, draw=black!70}
  }

  \node[b] (new) {Optimize\\New builds};
  \node[b, right=of new] (min) {Minimize\\Builds};
  \node[b, right=of min] (old) {Optimize\\Reused};

  \draw[arr] (new) -- (min);
  \draw[arr] (min) -- (old);
\end{tikzpicture}
\end{block}
\end{frame}


\section{Αποτελέσματα \& περιορισμοί}

\begin{frame}{Εφαρμογή σε \eng{E4S} και \eng{HPC} συστήματα}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.54\textwidth}
      \begin{block}{Περιβάλλον}
        \begin{itemize}
          \item \eng{E4S} repository
          \item \eng{Quartz} και \eng{Lassen}
        \end{itemize}
      \end{block}
      \begin{block}{Κύρια ευρήματα}
        \begin{itemize}
          \item Solve times: συνήθως \(< 1-10\) sec
          \item χρόνος \(\uparrow\) με πολλές εναλλακτικές εξαρτήσεις
          \item ρύθμιση \eng{clingo} tweety καλύτερη
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}{0.44\textwidth}
      \begin{alertblock}{Κλιμάκωση με reuse}
        \justifying
        Ακόμη και με \(\sim\)63.099 εγκατεστημένα πακέτα, ο solver παραμένει γρήγορος.
      \end{alertblock}
      \begin{block}{Bottleneck;}
        \justifying
        Μετατοπίζεται στην \eng{Python setup phase},
        όχι στο ίδιο το solving.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Αποτελέσματα}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.58\textwidth}
      \begin{block}{Τι άλλαξε ουσιαστικά}
        \begin{itemize}
          \item επιλύει σενάρια όπου ο greedy αποτυγχάνει
          \item καλύτερος χειρισμός: συγκρούσεις εκδόσεων + conditionals
          \item λύσεις εγγυημένα βέλτιστες βάσει κριτηρίων
        \end{itemize}
      \end{block}
      \begin{alertblock}{Συντηρησιμότητα}
        \justifying
        Κανόνες ASP \(\approx\) «γνώση» του συστήματος. Πιο καθαρό από heuristics που ξεφεύγουν με τον χρόνο.
      \end{alertblock}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{block}{Σύνοψη σύγκρισης}
        \footnotesize
        \begin{tabular}{@{}p{0.55\linewidth}p{0.38\linewidth}@{}}
          \toprule
          Χαρακτηριστικό & ASP concretizer \\
          \midrule
          Πληρότητα & Ναι \\
          Βελτιστοποίηση & Πολυκριτηριακή \\
          Variants/Conditionals & Φυσικά ενσωματωμένα \\
          Συντηρησιμότητα & Υψηλή \\
          \bottomrule
        \end{tabular}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Περιορισμοί}
  \begin{columns}[T,onlytextwidth]
    \begin{column}{0.50\textwidth}
      \begin{alertblock}{Setup overhead}
        \justifying
        Η γείωση + παραγωγή facts μπορεί να καθυστερήσει απλές εντολές.
      \end{alertblock}
      \begin{block}{Debugging όταν δεν υπάρχει λύση}
        \justifying
        \eng{SAT}-style εξηγήσεις δεν είναι πάντα «φιλικές» στον χρήστη.
      \end{block}
    \end{column}
    \begin{column}{0.46\textwidth}
      \begin{block}{Προοπτικές}
        \begin{itemize}
          \item βελτιστοποίηση setup phase
          \item incremental solving
          \item εφαρμογή ιδέας σε \eng{cloud orchestration}/\eng{microservices}
        \end{itemize}
      \end{block}
      \begin{block}{Takeaway}
        \justifying
        Ο ASP μετατρέπει την επίλυση εξαρτήσεων από ευριστικό «κόλπο» σε μαθηματικά ελεγχόμενη διαδικασία.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\section{Κλείσιμο}

\begin{frame}[plain]
  \vfill
  \begin{center}
    {\Huge\color{KRRBlue} Ευχαριστούμε για την προσοχή σας!}\\[0.4cm]
    \vspace{0.8cm}

  \end{center}
  \vfill
\end{frame}

\end{document}